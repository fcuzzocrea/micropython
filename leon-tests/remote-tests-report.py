#!/usr/bin/env python3
#
# This file is part of the MicroPython port to LEON platforms
# Copyright (c) 2015-2022 George Robotics Limited
#
# Provided to the European Space Agency as part of the project "Evolutions
# of MicroPython for LEON", contract number 4000137198/22/NL/MGu/kk.
#
# This script is the post-processing counterpart to remote-tests-prepare.sh.
# This script takes the expected test output generated by remote-tests-prepare.sh,
# and the actual output from the executable generated by that script, and compares
# them.  It prints out a report of the tests that passed and those that failed.

import argparse
import binascii
import re

re_expected_header = re.compile(
    rb"======== Expected output for (script [0-9]+|scripts \d+-\d+) : ([^ ]+) : (\d+) lines"
)
re_actual_header = re.compile(
    rb"======== Running (script \d+|scripts \d+-\d+)( with \d+ tasks)? ========"
)
hex_prefix = b"HEX "


class TestOutput:
    def __init__(self, id, name, output_num_lines, output):
        self.id = id
        self.name = name
        self.output_num_lines = output_num_lines
        self.output = b"".join(output).split(b"\n")


def parse_expected_file(filename):
    tests = []
    with open(filename, "rb") as f:
        while True:
            line = f.readline()
            if not line:
                break
            m = re_expected_header.match(line)
            assert m, line
            test_id = str(m.group(1), "ascii")
            test_name = str(m.group(2), "ascii")
            test_num_lines = int(m.group(3))
            test_output = list(f.readline() for _ in range(test_num_lines))
            tests.append(TestOutput(test_id, test_name, test_num_lines, test_output))
    return tests


def parse_actual_file(filename):
    tests = []
    with open(filename, "rb") as f:
        test_id = None
        test_output = []
        for line in f:
            m = re_actual_header.match(line)
            if m:
                if test_id is not None:
                    tests.append(TestOutput(test_id, None, None, test_output))
                test_id = str(m.group(1), "ascii")
                test_output = []
            elif line.startswith(hex_prefix):
                hex_data = line[len(hex_prefix) :].rstrip()
                try:
                    data = binascii.unhexlify(hex_data)
                except ValueError:
                    # hex_data had non-hex characters in in, most likely due to a
                    # crash of the target.  Try to extract as many valid hex
                    # characters as possible.
                    for i in range(0, len(hex_data), 2):
                        try:
                            data = binascii.unhexlify(hex_data[:i])
                        except ValueError:
                            break
                test_output.append(data)
        if test_id is not None:
            tests.append(TestOutput(test_id, None, None, test_output))
    return tests


def print_diff(lines_a, lines_b):
    for i, a in enumerate(lines_a):
        b = lines_b[i] if i < len(lines_b) else b""
        if a != b:
            if a:
                print("<", str(a, "ascii"))
            if b:
                print(">", str(b, "ascii"))


def check(expected_filename, actual_filename):
    tests_expected = parse_expected_file(expected_filename)
    tests_actual = parse_actual_file(actual_filename)
    num_passed = 0
    num_test_cases = 0
    name_failed = []
    for i, test in enumerate(tests_expected):
        test_passed = False
        if i < len(tests_actual):
            test_actual = tests_actual[i]
            if test.output == test_actual.output:
                test_passed = True
        if test_passed:
            print("pass ", test.name)
            num_passed += 1
        else:
            print("FAIL ", test.name)
            name_failed.append(test.name)
            if i < len(tests_actual):
                print_diff(test.output, tests_actual[i].output)
        num_test_cases += test.output_num_lines

    print(
        "{} tests performed ({} individual testcases)".format(
            len(tests_expected), num_test_cases
        )
    )
    print("{} tests passed".format(num_passed))
    if name_failed:
        print("{} tests failed - {}".format(len(name_failed), " ".join(name_failed)))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("expected", nargs=1, help="file with expected test output")
    parser.add_argument("actual", nargs=1, help="file with actual test output")
    args = parser.parse_args()
    check(args.expected[0], args.actual[0])


if __name__ == "__main__":
    main()
