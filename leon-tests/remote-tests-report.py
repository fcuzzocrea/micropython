#!/usr/bin/env python3
#
# This file is part of the MicroPython port to LEON platforms
# Copyright (c) 2015-2022 George Robotics Limited
#
# Provided to the European Space Agency as part of the project "Evolutions
# of MicroPython for LEON", contract number 4000137198/22/NL/MGu/kk.
#
# This script is the post-processing counterpart to remote-tests-prepare.sh.
# This script takes the expected test output generated by remote-tests-prepare.sh,
# and the actual output from the executable generated by that script, and compares
# them.  It prints out a report of the tests that passed and those that failed.

import argparse
import binascii
import re

re_expected_header = re.compile(
    rb"======== Expected output for script ([0-9]+) : ([A-Za-z0-9_/.-]+) : ([0-9]+) lines"
)
re_actual_header = re.compile(rb"======== Running script ([0-9]+) ========")
hex_prefix = b"HEX "


class TestOutput:
    def __init__(self, id, name, output_num_lines, output):
        self.id = id
        self.name = name
        self.output_num_lines = output_num_lines
        self.output = b"".join(output).split(b"\n")


def parse_expected_file(filename):
    tests = []
    with open(filename, "rb") as f:
        while True:
            line = f.readline()
            if not line:
                break
            m = re_expected_header.match(line)
            assert m, line
            test_id = int(m.group(1))
            test_name = str(m.group(2), "ascii")
            test_num_lines = int(m.group(3))
            test_output = list(f.readline() for _ in range(test_num_lines))
            tests.append(TestOutput(test_id, test_name, test_num_lines, test_output))
    return tests


def parse_actual_file(filename):
    tests = []
    with open(filename, "rb") as f:
        test_id = None
        test_output = []
        for line in f:
            m = re_actual_header.match(line)
            if m:
                if test_id is not None:
                    tests.append(TestOutput(test_id, None, None, test_output))
                test_id = int(m.group(1))
                test_output = []
            elif line.startswith(hex_prefix):
                test_output.append(binascii.unhexlify(line[len(hex_prefix) :].rstrip()))
        if test_id is not None:
            tests.append(TestOutput(test_id, None, None, test_output))
    return tests


def check(expected_filename, actual_filename):
    tests_expected = parse_expected_file(expected_filename)
    tests_actual = parse_actual_file(actual_filename)
    num_passed = 0
    num_test_cases = 0
    name_failed = []
    for i, test in enumerate(tests_expected):
        test_passed = False
        if i < len(tests_actual):
            test_actual = tests_actual[i]
            if test.output == test_actual.output:
                test_passed = True
            else:
                for j, line in enumerate(test.output):
                    if line != test_actual.output[j]:
                        print("<", line)
                        print(">", test_actual.output[j])
        if test_passed:
            print("pass ", test.name)
            num_passed += 1
        else:
            print("FAIL ", test.name)
            name_failed.append(test.name)
        num_test_cases += test.output_num_lines

    print(
        "{} tests performed ({} individual testcases)".format(
            len(tests_expected), num_test_cases
        )
    )
    print("{} tests passed".format(num_passed))
    if name_failed:
        print("{} tests failed - {}".format(len(name_failed), " ".join(name_failed)))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("expected", nargs=1, help="file with expected test output")
    parser.add_argument("actual", nargs=1, help="file with actual test output")
    args = parser.parse_args()
    check(args.expected[0], args.actual[0])


if __name__ == "__main__":
    main()
