/*
 * This file is part of the MicroPython port to MPFS platforms
 *
 * Based on LEON port originally made by George Robotics
 *
 * Copyright (c) 2023 Francescodario Cuzzocrea <bosconovic@gmail.com>
 */

/*
 * This file implements the fake ground task.
 */

#include <stdio.h>
#include <string.h>
#include <rtems.h>
#include "obcp.h"

#include "extmod/crypto-algorithms/sha256.h"

// include the precompiled bytecode (generated by external tools)
#include "scripts.h"

// 1 tick is 10 msec
#define MSEC_TO_TICKS(msec) ((int)(msec/10))

// Timeline a list of TCs separated by a delay
typedef struct {
    unsigned int delay_msec;
    TC_t tc;
} TIMELINE_ENTRY_T;

static TIMELINE_ENTRY_T timeline[] = {
    // load and start the task_therm.py script
    // (.u.data is: vm_id, script_id)
    { .delay_msec = 0,    .tc.generic = { .len = 3, .cmd = K_TC_CMD_MPY_LOAD, .data = { 0, 0 } } },
    { .delay_msec = 100,  .tc.generic = { .len = 3, .cmd = K_TC_CMD_MPY_START, .data = { 0, 0 } } },

    // load and start the task_power.py script (use vm=3 just to show it can be done)
    // (.u.data is: vm_id, script_id)
    { .delay_msec = 500,  .tc.generic = { .len = 3, .cmd = K_TC_CMD_MPY_LOAD, .data = { 3, 1 } } },
    { .delay_msec = 100,  .tc.generic = { .len = 3, .cmd = K_TC_CMD_MPY_START, .data = { 3, 1 } } },

    { .delay_msec = 1000, .tc.thresh = { .len = 24, .cmd = K_TC_CMD_SET_VOLT_THRESH, .channel = 0, .low = 1, .high = 2 } },
    { .delay_msec = 200,  .tc.thresh = { .len = 24, .cmd = K_TC_CMD_SET_CURR_THRESH, .channel = 8, .low = 0.1, .high = 0.2 } },
    { .delay_msec = 500,  .tc.thresh = { .len = 24, .cmd = K_TC_CMD_SET_CURR_THRESH, .channel = 8, .low = 0, .high = 0.5 } },
    { .delay_msec = 300,  .tc.thresh = { .len = 24, .cmd = K_TC_CMD_SET_VOLT_THRESH, .channel = 0, .low = 12, .high = 14 } },
};

// extension to RTEMS message queue API to keep trying if the queue is full
static rtems_status_code queue_send_wait(rtems_id q_id, void *data, size_t len) {
    rtems_status_code status = rtems_message_queue_send(q_id, data, len);
    if (status == RTEMS_TOO_MANY) {
        do {
            rtems_task_wake_after(1);
            status = rtems_message_queue_send(q_id, data, len);
        } while (status == RTEMS_TOO_MANY);
    }
    return status;
}

static rtems_status_code send_mpy_load(rtems_id q_id, TC_t *tc) {
    // Send an MPY file to a VM instance.  This is done by splitting up
    // the MPY into smaller pieces and posting a message per piece.

    int vm_id = tc->generic.data[0];
    int mpy_id = tc->generic.data[1];

    // get pointer to MPY data, and its length
    size_t mpy_len = mpy_script_len[mpy_id];
    const uint8_t *mpy_src = mpy_script_data[mpy_id];
    if (mpy_len >= 0x10000) {
        printf("FATAL: MPY too large\n");
        return -1;
    }

    // send MPY data, broken into chunks
    uint32_t off = 0;
    while (mpy_len > 0) {
        uint32_t len = mpy_len;
        if (len > sizeof(tc->mpy_load.data)) {
            len = sizeof(tc->mpy_load.data);
        }
        tc->mpy_load.len = 6 + len;
        tc->mpy_load.cmd = K_TC_CMD_MPY_LOAD;
        tc->mpy_load.vm_id = vm_id;
        tc->mpy_load.data_off = off;
        tc->mpy_load.data_len = len;
        memcpy(&tc->mpy_load.data[0], mpy_src + off, len);
        rtems_status_code status = queue_send_wait(q_id, tc, sizeof(TC_t));
        if (status != RTEMS_SUCCESSFUL) {
            return status;
        }
        mpy_len -= len;
        off += len;
    }

    return RTEMS_SUCCESSFUL;
}

static rtems_status_code send_mpy_start(rtems_id q_id, TC_t *tc) {
    // send an the SH256 hash of an MPY file to a VM instance, to start the script

    int vm_id = tc->generic.data[0];
    int mpy_id = tc->generic.data[1];

    // get pointer to MPY data, and its length
    size_t mpy_len = mpy_script_len[mpy_id];
    const uint8_t *mpy_src = mpy_script_data[mpy_id];
    if (mpy_len >= 0x10000) {
        printf("FATAL: MPY too large\n");
        return -1;
    }

    // create message
    tc->mpy_start.len = 4 + SHA256_BLOCK_SIZE;
    tc->mpy_start.cmd = K_TC_CMD_MPY_START;
    tc->mpy_start.vm_id = vm_id;
    tc->mpy_start.mpy_len = mpy_len;

    // compute SHA256 of MPY data
    CRYAL_SHA256_CTX sha_ctx;
    sha256_init(&sha_ctx);
    sha256_update(&sha_ctx, mpy_src, mpy_len);
    sha256_final(&sha_ctx, &tc->mpy_start.hash[0]);

    // send start command
    rtems_status_code status = queue_send_wait(q_id, tc, sizeof(TC_t));
    if (status != RTEMS_SUCCESSFUL) {
        return status;
    }

    return RTEMS_SUCCESSFUL;
}

rtems_task obcp_task_ground(rtems_task_argument task_arg) {
    set_start_time();
    printf("GND task started\n");

    rtems_status_code status;

    rtems_id tcq_id;
    rtems_name name = rtems_build_name('T', 'C', 'Q', ' ');
    status = rtems_message_queue_ident(name, RTEMS_SEARCH_ALL_NODES, &tcq_id);
    if (status != RTEMS_SUCCESSFUL) {
        printf("GND failed to initialise TC queue: %d\n", status);
        return;
    }

    for (int ix = 0; ix < sizeof(timeline) / sizeof(timeline[0]); ++ix) {
        TIMELINE_ENTRY_T *entry = &timeline[ix];

        // wait for specified delay before executing command
        rtems_task_wake_after(MSEC_TO_TICKS(entry->delay_msec));

        if (entry->tc.generic.len == 3 && entry->tc.generic.cmd == K_TC_CMD_MPY_LOAD) {
            status = send_mpy_load(tcq_id, &entry->tc);
            if (status != RTEMS_SUCCESSFUL) {
                printf("[%6.3f] GND: send on TC queue failed: %d\n", get_time(), status);
            } else {
                printf("[%6.3f] GND: sent MPY_LOAD on TC queue\n", get_time());
            }
        } else if (entry->tc.generic.len == 3 && entry->tc.generic.cmd == K_TC_CMD_MPY_START) {
            status = send_mpy_start(tcq_id, &entry->tc);
            if (status != RTEMS_SUCCESSFUL) {
                printf("[%6.3f] GND: send on TC queue failed: %d\n", get_time(), status);
            } else {
                printf("[%6.3f] GND: sent MPY_START on TC queue\n", get_time());
            }
        } else {
            // send the command verbatim
            status = rtems_message_queue_send(tcq_id, &entry->tc, sizeof(TC_t));
            if (status != RTEMS_SUCCESSFUL) {
                printf("[%6.3f] GND: send on TC queue failed: %d\n", get_time(), status);
            } else {
                printf("[%6.3f] GND: send on TC queue: %d\n", get_time(), ix);
            }
        }
    }

    printf("GND task ended\n");

    rtems_task_delete(RTEMS_SELF);
}
